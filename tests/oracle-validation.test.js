// Import the FloatingPoint class from the pure math module
const { FloatingPoint } = require('../lib/floating-point.js');
const fs = require('fs');
const path = require('path');

describe('Oracle Validation - IEEE 754 Hardware Compliance', () => {
  let oracleVectors;

  beforeAll(() => {
    // Load test vectors generated by Python's struct module (actual IEEE 754 hardware)
    const vectorPath = path.join(__dirname, 'oracle-vectors.json');
    const data = fs.readFileSync(vectorPath, 'utf8');
    oracleVectors = JSON.parse(data);
  });

  describe('FP32 Encode - Hardware Oracle Validation', () => {
    let fp32;

    beforeEach(() => {
      fp32 = new FloatingPoint(1, 8, 23);
    });

    test('validates against all oracle encode vectors', () => {
      oracleVectors.fp32_encode.forEach((vector) => {
        const input = vector.input === 'NaN' ? NaN : vector.input;
        const expected = vector.expected;
        const result = fp32.encode(input);

        // For NaN, we can't check exact mantissa value, just that it's non-zero
        if (expected.isNaN) {
          expect(result.isNaN).toBe(true);
          expect(result.exponent).toBe(expected.exponent);
          expect(result.mantissa).toBeGreaterThan(0);
        } else {
          expect(result.sign).toBe(expected.sign);
          expect(result.exponent).toBe(expected.exponent);
          expect(result.mantissa).toBe(expected.mantissa);
          expect(result.isZero).toBe(expected.isZero);
          expect(result.isSubnormal).toBe(expected.isSubnormal);
          expect(result.isNormal).toBe(expected.isNormal);
          expect(result.isInfinite).toBe(expected.isInfinite);
        }
      });
    });

    test('validates hex string matches IEEE 754 standard', () => {
      // Test specific known IEEE 754 hex values
      const testCases = [
        { value: 1.0, expectedHex: '0x3F800000' },
        { value: -1.0, expectedHex: '0xBF800000' },
        { value: 2.0, expectedHex: '0x40000000' },
        { value: 0.5, expectedHex: '0x3F000000' },
        { value: 0.0, expectedHex: '0x00000000' },
      ];

      testCases.forEach(({ value, expectedHex }) => {
        const encoded = fp32.encode(value);
        const hex = fp32.toHexString(encoded.sign, encoded.exponent, encoded.mantissa);
        expect(hex).toBe(expectedHex);
      });
    });

    test('validates binary string matches IEEE 754 standard', () => {
      const testCases = [
        { value: 1.0, expectedBinary: '00111111100000000000000000000000' },
        { value: -1.0, expectedBinary: '10111111100000000000000000000000' },
        { value: 2.0, expectedBinary: '01000000000000000000000000000000' },
      ];

      testCases.forEach(({ value, expectedBinary }) => {
        const encoded = fp32.encode(value);
        const binary = fp32.toBinaryString(encoded.sign, encoded.exponent, encoded.mantissa);
        expect(binary).toBe(expectedBinary);
      });
    });
  });

  describe('FP32 Decode - Hardware Oracle Validation', () => {
    let fp32;

    beforeEach(() => {
      fp32 = new FloatingPoint(1, 8, 23);
    });

    test('validates against all oracle decode vectors', () => {
      oracleVectors.fp32_decode.forEach((vector) => {
        const result = fp32.decode(vector.sign, vector.exponent, vector.mantissa);
        const expected = vector.expected;

        if (expected === 'NaN') {
          expect(isNaN(result)).toBe(true);
        } else if (expected === 'Infinity') {
          expect(result).toBe(Infinity);
        } else if (expected === '-Infinity') {
          expect(result).toBe(-Infinity);
        } else {
          // For finite values, check with appropriate precision
          if (Math.abs(expected) < 1e-30) {
            // Very small numbers - use relative comparison
            expect(result).toBeCloseTo(expected, 50);
          } else {
            // Use exact equality for normal numbers
            expect(result).toBe(expected);
          }
        }
      });
    });

    test('validates specific known IEEE 754 bit patterns', () => {
      // Use oracle-generated decode vectors which are verified against hardware
      // This prevents human calculation errors
      oracleVectors.fp32_decode.forEach((vector) => {
        const result = fp32.decode(vector.sign, vector.exponent, vector.mantissa);
        const expected = vector.expected;
        
        if (expected === 'NaN') {
          expect(isNaN(result)).toBe(true);
        } else if (expected === 'Infinity') {
          expect(result).toBe(Infinity);
        } else if (expected === '-Infinity') {
          expect(result).toBe(-Infinity);
        } else {
          expect(result).toBe(expected);
        }
      });
    });
  });

  describe('FP16 Encode - Oracle Validation', () => {
    let fp16;

    beforeEach(() => {
      fp16 = new FloatingPoint(1, 5, 10);
    });

    test('validates against all oracle FP16 vectors', () => {
      oracleVectors.fp16_encode.forEach((vector) => {
        const result = fp16.encode(vector.input);
        const expected = vector.expected;

        expect(result.sign).toBe(expected.sign);
        expect(result.exponent).toBe(expected.exponent);
        expect(result.mantissa).toBe(expected.mantissa);
        expect(result.isZero).toBe(expected.isZero);
        expect(result.isSubnormal).toBe(expected.isSubnormal);
        expect(result.isNormal).toBe(expected.isNormal);
        expect(result.isInfinite).toBe(expected.isInfinite);
        expect(result.isNaN).toBe(expected.isNaN);
      });
    });

    test('validates FP16 hex strings', () => {
      // Known FP16 hex values
      const testCases = [
        { value: 1.0, expectedHex: '0x3C00' },  // sign:0 exp:15 mant:0
        { value: -1.0, expectedHex: '0xBC00' }, // sign:1 exp:15 mant:0
        { value: 2.0, expectedHex: '0x4000' },  // sign:0 exp:16 mant:0
      ];

      testCases.forEach(({ value, expectedHex }) => {
        const encoded = fp16.encode(value);
        const hex = fp16.toHexString(encoded.sign, encoded.exponent, encoded.mantissa);
        expect(hex).toBe(expectedHex);
      });
    });
  });

  describe('Round-trip Validation with Oracle', () => {
    test('FP32 round-trip matches oracle decode→encode', () => {
      const fp32 = new FloatingPoint(1, 8, 23);

      // For each decode vector, verify encode produces same components
      oracleVectors.fp32_decode.forEach((vector) => {
        const decoded = fp32.decode(vector.sign, vector.exponent, vector.mantissa);
        
        // Skip NaN since it can have multiple representations
        if (isNaN(decoded)) return;
        
        const reencoded = fp32.encode(decoded);
        
        // Should produce exact same components
        expect(reencoded.sign).toBe(vector.sign);
        expect(reencoded.exponent).toBe(vector.exponent);
        expect(reencoded.mantissa).toBe(vector.mantissa);
      });
    });
  });

  describe('Mathematical Property Validation', () => {
    let fp32;

    beforeEach(() => {
      fp32 = new FloatingPoint(1, 8, 23);
    });

    test('validates sign bit correctly inverts value', () => {
      const testValues = [1.0, 2.5, 0.125, 100.0, 2**-10];
      
      testValues.forEach(value => {
        const positive = fp32.encode(value);
        const negative = fp32.encode(-value);
        
        // Sign bits should differ by exactly 1
        expect(negative.sign).toBe(1 - positive.sign);
        // Exponent and mantissa should be identical
        expect(negative.exponent).toBe(positive.exponent);
        expect(negative.mantissa).toBe(positive.mantissa);
      });
    });

    test('validates powers of 2 have zero mantissa', () => {
      const powers = [-10, -5, -1, 0, 1, 5, 10, 20];
      
      powers.forEach(power => {
        const value = Math.pow(2, power);
        const encoded = fp32.encode(value);
        
        // Powers of 2 should have mantissa = 0
        expect(encoded.mantissa).toBe(0);
        expect(encoded.isNormal).toBe(true);
        
        // Exponent should be bias + power
        expect(encoded.exponent).toBe(127 + power);
      });
    });

    test('validates exponent increases with magnitude', () => {
      const values = [0.125, 0.25, 0.5, 1.0, 2.0, 4.0, 8.0];
      const exponents = values.map(v => fp32.encode(v).exponent);
      
      // Exponents should be monotonically increasing
      for (let i = 1; i < exponents.length; i++) {
        expect(exponents[i]).toBeGreaterThan(exponents[i-1]);
      }
    });

    test('validates subnormal threshold at 2^-126', () => {
      const fp32 = new FloatingPoint(1, 8, 23);
      
      // 2^-126 is smallest normal
      const minNormal = Math.pow(2, -126);
      const encodedNormal = fp32.encode(minNormal);
      expect(encodedNormal.isNormal).toBe(true);
      expect(encodedNormal.exponent).toBe(1);
      
      // Anything smaller should be subnormal or zero
      const subnormal = Math.pow(2, -127);
      const encodedSub = fp32.encode(subnormal);
      expect(encodedSub.isSubnormal || encodedSub.isZero).toBe(true);
      expect(encodedSub.exponent).toBe(0);
    });
  });

  describe('Independent Calculation Validation', () => {
    test('manually calculates 1.5 encoding', () => {
      // 1.5 = 1.1 in binary = 1.5 × 2^0
      // Sign: 0 (positive)
      // Exponent: 0 + 127 = 127
      // Mantissa: 0.5 = 0x400000 (bit 22 set, which represents 2^-1)
      
      const fp32 = new FloatingPoint(1, 8, 23);
      const result = fp32.encode(1.5);
      
      expect(result.sign).toBe(0);
      expect(result.exponent).toBe(127);
      expect(result.mantissa).toBe(0x400000); // 4194304 in decimal
    });

    test('manually calculates 6.5 encoding', () => {
      // 6.5 = 110.1 in binary = 1.101 × 2^2
      // Sign: 0
      // Exponent: 2 + 127 = 129
      // Mantissa: 0.101 in binary = 0.625 decimal
      //           = 0x500000 (bits 22 and 20 set)
      
      const fp32 = new FloatingPoint(1, 8, 23);
      const result = fp32.encode(6.5);
      
      expect(result.sign).toBe(0);
      expect(result.exponent).toBe(129);
      expect(result.mantissa).toBe(0x500000); // 5242880 in decimal
    });

    test('manually validates smallest subnormal', () => {
      // Smallest subnormal FP32 = 2^-149
      // This is 2^-23 (mantissa precision) × 2^-126 (min exponent)
      // Sign: 0
      // Exponent: 0 (subnormal)
      // Mantissa: 1 (smallest non-zero mantissa)
      
      const fp32 = new FloatingPoint(1, 8, 23);
      const minSubnormal = Math.pow(2, -149);
      const result = fp32.encode(minSubnormal);
      
      expect(result.sign).toBe(0);
      expect(result.exponent).toBe(0);
      expect(result.mantissa).toBe(1);
      expect(result.isSubnormal).toBe(true);
    });
  });
});
